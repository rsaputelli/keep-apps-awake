name: Keep Streamlit Apps Awake

on:
  schedule:
    - cron: "*/15 * * * *"   # every 15 minutes (UTC)
  workflow_dispatch:

concurrency:
  group: keep-streamlit-awake
  cancel-in-progress: true

jobs:
  wake:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Check out repo
        uses: actions/checkout@v4

      - name: Show URL list (sanity check)
        run: |
          echo "Working directory: $PWD"
          echo "urls.txt contents:"
          cat urls.txt

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Playwright (Chromium)
        run: |
          npm i playwright@^1
          npx playwright install --with-deps chromium

      - name: Visit apps like a real user (auto-wake for 'Yes, get this app back up!')
        env:
          URL_LIST: "urls.txt"
          DWELL_MS: "20000"        # keep page open 20s once live
          MAX_WAIT_MS: "600000"    # up to 10 minutes for cold starts
        run: |
          node - <<'JS'
          const fs = require('fs');
          const { chromium } = require('playwright');

          async function clickWake(page) {
            // Handle cookie banners that can block the button
            const cookieButtons = [/accept/i, /agree/i, /consent/i, /ok/i, /got it/i];
            for (const re of cookieButtons) {
              try {
                const b = page.getByRole('button', { name: re }).first();
                if (await b.isVisible()) { await b.click({ timeout: 3000 }).catch(()=>{}); }
              } catch {}
            }

            // Click the exact Streamlit wake button
            const exact = /Yes,\s*get this app back up!?/i;
            try {
              const b1 = page.getByRole('button', { name: exact }).first();
              if (await b1.isVisible().catch(()=>false)) {
                console.log('Clicking wake button (role match)…');
                await b1.click({ timeout: 5000 }).catch(()=>{});
                return true;
              }
            } catch {}

            try {
              const b2 = page.locator('button:has-text("Yes, get this app back up")').first();
              if (await b2.isVisible().catch(()=>false)) {
                console.log('Clicking wake button (text locator)…');
                await b2.click({ timeout: 5000 }).catch(()=>{});
                return true;
              }
            } catch {}

            // Fallback: any visible button/link containing "get this app back up"
            try {
              const any = page.locator('button, a').filter({ hasText: /get this app back up/i }).first();
              if (await any.isVisible().catch(()=>false)) {
                console.log('Clicking wake button (fallback)…');
                await any.click({ timeout: 5000 }).catch(()=>{});
                return true;
              }
            } catch {}

            return false;
          }

          async function waitUntilLive(page, maxWaitMs) {
            let wsOpened = false;
            page.on('websocket', () => { wsOpened = true; });
            const liveSel = ['[data-testid="stAppViewContainer"]','section.main','[data-testid="stSidebar"]'];
            const start = Date.now();

            while (Date.now() - start < maxWaitMs) {
              await clickWake(page);                       // try to wake if prompt present
              if (wsOpened) return true;                   // Streamlit WS established
              for (const s of liveSel) {                   // DOM shows real app
                if (await page.$(s)) return true;
              }
              await page.waitForTimeout(5000);
            }
            return false;
          }

          (async () => {
            const listPath = process.env.URL_LIST || 'urls.txt';
            const dwell = parseInt(process.env.DWELL_MS || '20000', 10);
            const maxWait = parseInt(process.env.MAX_WAIT_MS || '600000', 10);

            if (!fs.existsSync(listPath)) throw new Error(`URL list not found: ${listPath}`);
            const urls = fs.readFileSync(listPath, 'utf8')
              .split(/\r?\n/).map(s => s.trim()).filter(s => s && !s.startsWith('#'));

            const browser = await chromium.launch({ headless: true, args: ['--no-sandbox'] });
            const ctx = await browser.newContext({
              userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123 Safari/537.36',
              viewport: { width: 1280, height: 800 }
            });

            for (const url of urls) {
              const page = await ctx.newPage();
              console.log('Opening', url);
              try {
                await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 180000 });
                const live = await waitUntilLive(page, maxWait);
                if (!live) {
                  console.error('Timeout waiting for app:', url);
                } else {
                  await page.waitForTimeout(dwell);
                  console.log('Kept alive:', url);
                }
              } catch (e) {
                console.error('Failed on', url, e.toString());
              } finally {
                await page.close().catch(()=>{});
              }
            }

            await ctx.close();
            await browser.close();
          })();
          JS

